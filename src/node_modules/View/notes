mod.render()
	triggers re-render of all mod.views
	mod.views can have .content functions that bind to the mod, and just rebuild the whole view from scratch

View.AutoSub --> Use this to be more explicit regarding the auto_sub feature.

View.extend({
	MyAutoSubView: View.AutoSub.extend({}),
	MySubView: View.extend(),
	content: function(){
		this.myAutoSubView.render(); // automatically created
		this.named = this.MySubView(); // create instance
			// this is a little quicker/easier/more intuitive, but when it comes to modifying classes, the auto_sub is easier, because you don't have to override methods and copy+paste
	}
});

If you just need a subview... 

Rather than have to manually extend from View.AutoSub, could we make a method to do it?

View.extend({});

View("append", "all", "of", "these");


View.extend("append") ??
The $el, while present, doesn't copy any contents...

Maybe we append everything to a .contents[] array?
There shouldn't be a .content and .contents[] api...

Maybe when we append several values like that, they just get appended to .content[] array...

But then we need to handle content as:

viewable
	str
	bool
	num
	function: capture
	function: return
	view
	DOM
	jQuery
	mod w/ .render()
		treats the fn as either a capture fn, and/or a return fn
	array of viewables

mod.render()
	returns function(){}
		returns function(){}
			--> keeps capturing/looking for returned value to use as rendered content

.render() can return any viewable value

if .render() returns something with .render(), or a fn, we need to call it, and see what happens...


view.capture(viewable)
	- append str, bool, num, 


What if each view has an internal pointer to its.. $inbox?  No, we don't need to capture to different containers - only one $el per view?


So, view.capture(viewable) could work.  It's basically "append", but will handle unique cases?

Also, what about binding.  Now that I have Properties, I need to figure out how to do bindings...

So, View.extend( viewable (pretty much any non-object, or obj w/ .render?) --> capture? )
	You couldn't pass a POJO with .render, without wrapping it in a {
		capture: { render: function(){} /*fake view*/ }
	}

	because POJO would be --> .set

Then create a special class for block:

block("nameAndClass class-two", function(){});
	// do we try and install this when its captured?
	// no - even though this appears "functional", its actually object oriented
	// just use this.whatever = block("whatever", function(){}); and make it very clear what's going on.
	// do we need an accurate .name, then? adding the classes is probably enough.

block(function(){
	this becomes the content fn
});

block(function(){}, function(){});
// append both fns to a content array?

Do we really need this "block" syntax?
Why not just use div(function(){
	this.addClass("whatever"); //?  just as good..
});










