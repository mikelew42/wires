var Mod1 = require("mod42/Mod1");
var is = require("is");
var logger = require("log42/logger");

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var getParamNames = function(func) {
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  return result || [];
}

var Method = module.exports = Mod1.extend({
	name: "Method",
	enabled: true,
	disabled: false,
	expand: true,
	disable_return: true,
	args: "names",
	// argLabel: "",
	enable: function(value){
		if (value === false){
			this.enabled = false;
			this.disabled = true;
		} else {
			this.enabled = true;
			this.disabled = false;
		}
	},
	disable: function(value){
		if (value === false){
			this.disabled = false;
			this.enabled = true;
		} else {
			this.disabled = true;
			this.enabled = false;
		}
	},
	init: function(){
		// if (this.name === "assign")
		// 	debugger;
		this.argNames = getParamNames(this.method || function(){});
	},
	wrapper: function(){
		var methodLogger, wrapped;

		if (this.disabled)
			return this.method;

		methodLogger = this;

		wrapped = function(){
			return methodLogger.execWrapper(this, arguments);
		};

		for (var i in this.method){
			wrapped[i] = this.method[i];
		}

		wrapped.wrapped = true;
		wrapped.method = this;
		wrapped.fn = this.method;
		return wrapped;
	},

	execWrapper: function(ctx, args){
		// TODO: suppress if method is turned off...
		// if (this.name === "assign")
		// 	debugger
		return this.logAndExecMethod(ctx, args);
	},

	logAndExecMethod: function(ctx, args){
		var log;

		if (this.disabled){
			return this.method.apply(ctx, args);
		}

		log = ctx.log || logger();
		// open group
		if (this.expand)
			log.group.apply(console, this.methodLabel(ctx, args));
		else
			log.groupc.apply(console, this.methodLabel(ctx, args));

		// capture return value
		ret = this.method.apply(ctx, args);
		
		// close group
		this.ret(ret, ctx);
		return ret;
	},

	methodLabel: function(ctx, args){
		// a wrapped method can be anywhere on a prototype chain, and be called by many different ctx
		if (ctx.name){
				this.tmpName = ctx.name + "{" + ctx.id + "}" + "." + this.name;
		}
		return this.fnLabel(ctx, args);
	},

	fnLabel: function(ctx, args){
		var name = this.tmpName || this.name || "anonymous";
		var argNames = this.argNames;

		var label = [ name + "(" ], argName;

		if (is.def(this.argLabel)){
			label.push(this.argLabel);
		} else if (argNames.length){

			// build argName: argValue, ...
			for (var i = 0; i < argNames.length; i++){
				argName = argNames[i];
				if (argName)
					label.push(argName+":");
				
				if (is.simple(args[i]))
					label.push(args[i]);
				else
					label.push(args[i].toString().substring(0, 8))

				if (i < argNames.length - 1){
					label.push(",");
				}
			}

			// add additional anonymous arguments
			if (i < args.length){
				label.push(",");
				for (i; i < args.length; i++){
					label.push(args[i]);
					if (i < args.length - 1)
						label.push(",");
				}
			}

		// the function defines no args, these are all anonymous args
		} else if (args.length){
			for (var j = 0; j < args.length; j++){
				label.push(args[j]);
				if (j < args.length - 1)
					label.push(",");
			}
		}
		label.push(")");
		return label;
	},

	ret: function(retValue, ctx){
		var log = ctx.log || logger();
		if (this.disable_return){
			log.end();
			return false;
		}
		if (is.fn(retValue)){
			retValue = retValue.toString().split("{")[0];
		}

		if (retValue === ctx){
			log.end();
			return false;
		}

		// this.contain can be undefined/"auto", true, or false
		if (!is.def(this.contain) || this.contain === "auto"){
			// log return value after the group
			if (is.def(retValue)){
				log.end();
				log("  return", retValue);
			// or not at all
			} else {
				log.end();
			}
		} else if (this.contain === true){
			log("return", retValue);
			log.end();
		} else if (this.contain === false){
			log.end();
			log("  return", retValue);
		}

	}
});