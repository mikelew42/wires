var test = require("test42");

var Mod = require("mod42/Mod4");
var view = require("view42/View1");

/*

Create a "database" with every number between 1-100,000? 1,000,000?

Well, let's loop to 1000, and create all multiples, and see where we're at.

We want to identify every number in its simplest form

1 ==> prime
	1*1 ==> 1 ==> already have it, skip
2 ==> prime
	2* every prime so far
		2*1 ==> 2 ==> skip
		2*2 ==> 4 ==> add as prime power?
3 ==> prime


All numbers are either primes, or multiples of 2 or more primes
When we come to a new prime, we multiple it by every other prime, including itself.  Maybe we go ahead and create n_powers


In order to do computations, we'll want to create a new number instance for each number, and that instance will have a collection of factors.

As we perform arithmetic, we either remove factors...

We need to store prime factors by each prime.

3 2's
5 3's
7 5's...


Essentially, its a combination of the PrimePowers

When we create a Prime, we multiple by all existing numbers, even those much larger than itself.

All existing numbers are PrimePowers or PrimeMultiples

Prime Multiples are.. just numbers:
	PrimePower * PrimePower * PrimePower...


How do we create the numbers (and the factors):

When we multiply a new Prime by all existing numbers, we basically just add up the PrimePowers

If one number has PrimePowers:

2^3
3^8
7^6

and another 

2^5

then we get

2^8
3^8
7^6
...



Even better than creating a new unknown number from the factors of multiplication/division, we could try to index numbers by their prime powers...?


Something like...
2^n
	&& 3^m
		&& 5^l
		...

So that when you do a multiplication or division, you retrieve the result from the number base...

When you multiply 2 numbers, you're just adding up the prime components
When you're dividing 2 numbers, you're subtracting them

When you divide, and you go negative, these should just stay as negative exponents...



*/

var Number = Mod.extend({
	name: "Number",
	init: function(){
		// console.log("new number");
		// a set of primePowers
		this.init_factors();
		// this.render();
	},
	init_factors: function(){
		this.number = 1;
		this.factorization = "";
		for (var i in this.factors){
			this.number = this.number * this.factors[i].number;
			this.factorization += "[" + this.factors[i].factorization + "]"
		}
		// console.log("new number:", this.number, this.factorization);
	},
	render: function(){
		view("Number ", this.number, " ", this.factorization);
	},
	multiply: function(number){
		var newFactors = {};
		var factor;

		for (var i in number.factors){
			factor = number.factors[i];

			if (this.factors[i])
				newFactors[i] = this.factors[i].plus(factor.n);
			else
				newFactors[i] = factor;
		}

		// add the remaining factors that are only in this
		for (var i in this.factors){
			if (number.factors[i])
				continue;
			
			newFactors[i] = this.factors[i];
		}

		return Number({
			factors: newFactors
		})
	},
	divide: function(number){
		var newFactors = {};
		var factor;

		for (var i in number.factors){
			factor = number.factors[i];

			if (this.factors[i])
				newFactors[i] = this.factors[i].minus(factor.n);
			else
				newFactors[i] = factor;
		}

		// add the remaining factors that are only in this
		for (var i in this.factors){
			if (number.factors[i])
				continue;
			
			newFactors[i] = this.factors[i];
		}

		return Number({
			factors: newFactors
		})
	}
});

var limit = 1000;
// var n_powers = 100;

var Prime = Number.extend({
	name: "Prime",
	init: function(){
		this.factorization = "-";
		this.factors = [];
		this.multiples = [];

		var prime = this;
		// view(function(){
			// this.append("Prime:", prime.number);
			// view(function(){
				// this.css("padding-left", "10px");
				prime.createPowers();
				prime.factors[prime.number] = prime.powers[prime.number];
				prime.createMultiples();
			// });
		// });
	},
	createPowers: function(){
		this.powers = [];
		var n = 1; // current power
		var power;
		var result = this.number;

		this.powersByPower = {};

		do {
			
			power = new PrimePower({
				number: result,
				n: n,
				prime: this
			});

			this.powers[result] = power;
			this.powersByPower[n] = power;

			if (!this.numbers[result])
				this.numbers[result] = power;
			
			this.multiples[result] = power;

			if (this.number === 1)
				return;

			n++;
			result = Math.pow(this.number, n);  

		} while (result < limit);
	},
	createMultiples: function(){
		// console.log("multiples");
		var result,
			number;


		// view(function(v){
		// 	v.append("Multiples").css("margin", "10px 0px");

		// 	view(function(v){
		// 		v.css("padding-left", "10px");
				
				for (var i in this.numbers){
					number = this.numbers[i];
					if (number.number === 1 || number.number > limit || number === this || (number.prime && number.prime === this)){
						// view("skipping", number.number);
						continue;
					}
					// console.log("multiply by ", number.number);
					// view(this.number, "x", number.number);
					// view(function(v){
						// v.css("padding-left", "10px");

						this.createMultiple(number);

					// }.bind(this));
				}

		// 	}.bind(this));
			
		// }.bind(this));
	},
	createMultiple: function(number){
		var n = this.number * number.number,
			result;

		if (n > limit)
			return;

		if (!this.numbers[ n ]){
			result = number.multiply(this);
			this.numbers[result.number] = result;
			if (result.number < limit)
				this.createMultiple(result, limit);
		}
	}
});

var PrimeMultiple = Mod.extend({
	name: "PrimeMultiple"
})

var PrimePower = Number.extend({
	name: "PrimePower",
	init: function(){
		this.factorization = this.prime.number + "^" + this.n;
		// this.factors = [this];
		// console.log("PrimePower:", this.number, "("+this.factorization+")");


		this.factors = [this];

		// this.render();
	},
	render: function(){
		view("PrimePower:", this.number, "("+this.prime.number+"^"+this.n+")");
	},
	minus: function(n){
		return this.prime.powersByPower[this.n - n];
	},
	plus: function(n){
		return this.prime.powersByPower[this.n + n];
	}
});

var Numbers = Mod.extend({
	init: function(){
		this.createNumbers();
	},
	createNumbers: function(){
		this.numbers = {};
		this.primes = {};
		for (var i = 1; i < limit; i++){
			// console.log(this.numbers);
			if (!this.numbers[i]){
				this.primes[i] = Prime({
					number: i,
					numbers: this.numbers
				});
			}
		}
	},
	inOrder: function(){
		console.group("in order")
		for (var i = 1; i < limit; i++){
			console.log(i, this.numbers[i] && this.numbers[i].factorization , this.numbers[i].name);
		}
		console.groupEnd();
	},
	logPrimes: function(){
		var last;
		console.group("primes");
		for (var i in this.primes){
			console.log(this.primes[i].number, last ? this.primes[i].number - last.number : "" );
			last = this.primes[i];
		}
		console.groupEnd();
	}
});

var numbers = Numbers();

var multiply = function(one, two){
	var num1 = numbers.numbers[one];
	var num2 = numbers.numbers[two];

	return num1.multiply(num2).number
}

test("numbers", function(){
	console.groupCollapsed("create");
	console.groupEnd();

	// numbers.inOrder();

	// numbers.logPrimes();

	test.assert(multiply(1, 828) === 234*828);

	// for (var i = 1; i < 100; i++)
	// 	test.assert(multiply(i, i+3*2));

});

/*

In order to test my theory, we need to retrieve the number that matches, which is already composed of the primes.

But, in order to perform arbitrary calculations with them, we might need to clone them...


So, maybe the numbers are cloneable, and PrimePowers are the factors

Or, we create a new class of Number, look up the number's factors, and copy them?
We don't need to copy the powers.  We just need to increment/decrement them...


Ugh - but then we have to handle less than 1.  If x/y is less than one, we have decimal shit to deal with..


*/



