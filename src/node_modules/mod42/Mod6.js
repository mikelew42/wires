var Mod5 = require("./Mod5");
var is = require("is");
var ExtendMfn = require("./ExtendMfn");
var SetMfn = require("./SetMfn");

var Settings = Mod5.Settings;


var Mod55 = Mod5.extend({
	name: "Mod55",
	settings: Settings({
		update: function(name){
			var setter = {};
			if (!this.hasOwnProperty("parent"))
				console.error("shouldn't happen");

			setter[name] = this.parent[name];
			this.parent.set(setter); // re-wrap it
		}
	})
}).set({
	extend: {
		then: function(Ext){
			rewrap(Ext.prototype);
		}
	}
});

var rewrap = function(mod){
	var settings, methods, props, method;
	if (mod.hasOwnProperty("settings")){
		settings = mod.settings;
		if (settings.hasOwnProperty("methods")){
			methods = settings.methods;
			for (var i in methods){
				if (methods.hasOwnProperty(i)){
					method = (mod[i] && mod[i].fn) || mod[i];
					mod.set.mfn.wrapMethod(mod, i, method);
				}
			}
		}
		if (settings.hasOwnProperty("props")){
			props = settings.props;
			for (var i in props){
				if (props.hasOwnProperty(i)){
					mod.set.mfn.wrapProperty(mod, i, mod[i]);
				}
			}
		}
	}	
};

// Upgrade .set to use .set, so that we can auto-extend .set.Classes
Mod55.prototype.set.mfn.constructor.extend = ExtendMfn.make();
Mod55.prototype.set.mfn.constructor.prototype.set = SetMfn.make(); 

var Mod6 = Mod55.extend({
	name: "Mod6",
	set: {
		wrapMethod: function(mod, name, fn){
			var settings = mod.settings && mod.settings.data();
			console.log(name, settings);

			mod[name] = new this.Method({
				name: name,
				method: fn
			}, settings && 
			   settings.methods && 
			   settings.methods[name] ).wrapper();
		},
		wrapProperty: function(mod, name, value){
			var settings = mod.settings && mod.settings.data();
			console.log(name, settings);

			new this.Property({
				name: name,
				parent: mod,
				value: value
			}, settings && 
			   settings.props &&
			   settings.props[name] );
		},
		then: function(mod){
			rewrap(mod);
		},
		Method: {},
		Property: {}
	}
});

module.exports = Mod6;

/*

REWRAPPING WHEN ADDITIONS/MODIFICATIONS ARE MADE TO METHODS/PROPERTIES
- Previously wrapped methods won't use the new Methods/Properties and their constructs
- This goes for the base Mod6, but also any interim classes:

Example: ModN configures and wraps a bunch of methods/properties.
ModN+1 changes that configuration.
ModN+1 needs to then re-wrap those methods/properties, to use the new config.

settings: {
	methods: Settings({
		set: {
			contextual: fn(){
				// when adding or modifying a property/method, we could re-wrap it
			}
		}
	})
}


CAN'T CONFIGURE INIT, INITIALIZE, INSTANTIATE, SET, ASSIGN, OR DATA
Well, shit...  How do we get around this?  Prefix all?  Prefix just those?

Auto prefix all?
- When setting a new property on a MethodSettings or PropertySettings, automatically append a double underscore.
-  set: { method: { init: {settings} }}
   --> set.method.__init
-  then, when wrapping, always check settings["__"+name]

God, that's ugly.

.settings.set is ok
.settings.methods._$_set?
.settings.methods._$_initialize?

remap the settings methods to different names?
the problem is getting it to work with mod.set({settings: {} })

*/