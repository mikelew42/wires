var Mod5 = require("./Mod5");
var is = require("is");
var ExtendMfn = require("./ExtendMfn");
var SetMfn = require("./SetMfn");

var Settings = Mod5.Settings;

var rewrap = function(mod){
	var settings = mod.settings.data(true),
		methods = settings.methods,
		method,
		props = settings.props;

	for (var i in methods){
		method = (mod[i] && mod[i].fn) || mod[i];
		mod.set.mfn.wrapMethod(mod, i, method);
	}

	for (var i in props){
		mod.set.mfn.wrapProperty(mod, i, mod[i]);
	}
};

var Mod55 = Mod5.extend({
	name: "Mod55",
	settings: Settings()
}).set({
	extend: {
		then: function(Ext){
			// console.group("extend then rewrap");
			rewrap(Ext.prototype);
			// console.groupEnd();
		}
	}
});


// Upgrade .set to use .set, so that we can auto-extend .set.Classes
Mod55.prototype.set.mfn.constructor.extend = ExtendMfn.make();
Mod55.prototype.set.mfn.constructor.prototype.set = SetMfn.make(); 

var Mod6 = Mod55.extend({
	name: "Mod6",
	set: {
		wrapMethod: function(mod, name, fn){
			var settings = mod.settings && mod.settings.data();
			// console.log(name, settings);

			mod[name] = new this.Method({
				name: name,
				method: fn
			}, settings && 
			   settings.methods && 
			   settings.methods[name] ).wrapper();
		},
		wrapProperty: function(mod, name, value){
			var settings = mod.settings && mod.settings.data();
			// console.log(name, settings);

			new this.Property({
				name: name,
				parent: mod,
				value: value
			}, settings && 
			   settings.props &&
			   settings.props[name] );
		},
		then: function(mod){
			rewrap(mod);
		},
		Method: {},
		Property: {}
	}
});

Mod6.prototype.set.mfn.wrapMethod(Mod6, "extend", Mod6.extend);
// Mod6.prototype.set.mfn.wrapMethod(Mod6, "extend", Mod6.extend);

module.exports = Mod6;

/*

REWRAPPING WHEN ADDITIONS/MODIFICATIONS ARE MADE TO METHODS/PROPERTIES
- Previously wrapped methods won't use the new Methods/Properties and their constructs
- This goes for the base Mod6, but also any interim classes:

Example: ModN configures and wraps a bunch of methods/properties.
ModN+1 changes that configuration.
ModN+1 needs to then re-wrap those methods/properties, to use the new config.

settings: {
	methods: Settings({
		set: {
			contextual: fn(){
				// when adding or modifying a property/method, we could re-wrap it
			}
		}
	})
}


CAN'T CONFIGURE INIT, INITIALIZE, INSTANTIATE, SET, ASSIGN, OR DATA
Well, shit...  How do we get around this?  Prefix all?  Prefix just those?

Auto prefix all?
- When setting a new property on a MethodSettings or PropertySettings, automatically append a double underscore.
-  set: { method: { init: {settings} }}
   --> set.method.__init
-  then, when wrapping, always check settings["__"+name]

God, that's ugly.

.settings.set is ok
.settings.methods._$_set?
.settings.methods._$_initialize?

remap the settings methods to different names?
the problem is getting it to work with mod.set({settings: {} })

*/