var Mod1 = require("./Mod1");
var track = require("track");
var is = require("is");

var cloneArray = function(arr, parent, swap, arrName){
	var clone = [];
	var value;


	for (var i = 0; i < arr.length; i++){
		value = arr[i];
		if (value && value.clone && value.parent && value.parent === parent.proto){
			swap.push({
				index: i,
				name: value.name,
				arrName: arrName
			});
		} else {
			clone[i] = arr[i];
		}
	}

	return clone;
}
/*
Problem:  When trying to assign a reference that by chance hasn't been adopted yet, it gets adopted incorrectly...

Also, I was thinking today there's another big problem with this array cloning scheme... Can't remember though
*/
var Mod4 = module.exports = Mod1.extend({
	name: "Mod4",
	set: {
		stdProp: function(mod, prop, value){
			mod[prop] = value;

			if (value && is.fn(value.setup) && prop !== "parent")
				value.setup(mod, prop);
		}
	},
	instantiate: function(){
		this.protect();
		this.set.apply(this, arguments);
		this.initialize.apply(this, arguments);
	},
	protect: function(){
		var prop, clones = [], swap = [];
		for (var i in this){
			if (["constructor", "base", "proto", "parent"].indexOf(i) > -1)
				continue;
			if (this.hasOwnProperty(i))
				continue;
			prop = this[i];
			if (prop && prop.clone && prop.parent && prop.parent === this.proto){
				this[i] = prop.clone({
					parent: this,
					name: i
				});
				clones.push(i);
			} else if (is.arr(prop)){
				this[i] = cloneArray(prop, this, swap, i);
			}
		}

		// basically, this.something = childMod that gets cloned
		// and, this.arrName[index] === this.something
		// and we need to swap out that index for the new clone...  :/
		for (var i = 0; i < swap.length; i++){
			if (clones.indexOf(swap[i].name) > -1){
				this[swap[i].arrName][swap[i].index] = this[swap[i].name];
			}
		}
	},
	clone: function(){
		var clone = Object.create(this);
		track(clone);
		clone.proto = this;
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});

// auto adopt
// leave .setup on the Mod, and use an autoAdopt flag?
	// that allows any Mod to get adopted by simply setting the flag
	// but, its just as easy to use Mod.Sub()...
Mod4.Sub = Mod4.extend({
	name: "Sub",
	setup: function(parent, name){
		if (parent && !this.hasOwnProperty("parent")){
			this.parent = parent;
		}

		if (name && !this.hasOwnProperty("name")){
			this.name = name;
		}
	}
})