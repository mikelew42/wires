var Mfn = require("mod42/Mfn");
var is = require("is");

var SetMfn = module.exports = Mfn.extend({
	name: "SetMfn",
	main: function(mod){
		var args = [].slice.call(arguments, 1); // chop off the first arg
		for (var i = 0; i < args.length; i++){
			this.arg(mod, args[i]); // keep mod as first arg
		}
		this.then(mod);
		return mod; // important - see .prop method, where .set() return value is reassigned to parent...
	},
	arg: function(mod, arg){
		if (is.obj(arg))
			this.obj(mod, arg);
		else if (is.str(arg) && this.str)
			this.str(mod, arg);
		else if (is.num(arg) && this.num)
			this.num(mod, arg);
		else if (is.bool(arg) && this.bool)
			this.bool(mod, arg);
		else if (is.undef(arg) && this.undef)
			this.undef(mod, arg);
		else if (is.fn(arg) && this.setFn)
			this.setFn(mod, arg); // .fn is taken..
		else if (this.other)
			this.other(mod, arg);
		else if (is.undef(arg))
			return;
		else
			console.warn("not sure how to set this", arg);
	},
	obj: function(mod, obj){
		for (var i in obj){
			this.prop(mod, obj, i);
		}
	},
	// todo: copy if !hasOwn, and then deep extend objects
	// todo: copy arrays if !hasOwn, and do push operations?
	prop: function(mod, obj, i){
		var modProp = mod[i];
		if (is.undef(modProp)){
			this.stdProp(mod, obj, i);
		} else if (is.Class(modProp)) {
			this.ClassProp(mod, obj, i);
		} else if (modProp.set) { // dependent on is.def(mod[i])
			this.propWithSet(mod, obj, i);
		} else if (is.fn(modProp)) {
			this.fnProp(mod, obj, i);
		} else if (is.obj(modProp)){
			this.objProp(mod, obj, i); // not yet implemented
		} else if (is.arr(modProp)){
			this.arrProp(mod, obj, i); // not yet implemented
		} else {
			this.stdProp(mod, obj, i);
		}
	},
	// "prop with .set"
	propWithSet: function(mod, obj, i){
		if (!mod.hasOwnProperty[i] && !mod[i].mfn)
			console.warn("potentially unsafe modification of prototype chain:", i); // unless you return a fresh instance from .set
		// send this through stdProp?
		mod[i] = mod[i].set(obj[i]);
	},
	ClassProp: function(mod, obj, i){
		if (is.Class(obj[i])){
			this.stdProp(mod, obj, i);
		} else if (mod.hasOwnProperty(i)) {
			mod[i].prototype.set(obj[i]);
		} else {
			// send this through stdProp?
			mod[i] = mod[i].extend(obj[i]); // protect mod's prototype
		}
	},
	// there should be a set_property(mod, name, value) function, without the setter object...
	stdProp: function(mod, obj, i){
		mod[i] = obj[i];
	},
	fnProp: function(mod, obj, i){
		if (is.fn(obj[i])){
			this.stdProp(mod, obj, i);
		} else {
			if (is.arr(obj[i])){
				mod[i].apply(mod, obj[i]);
			} else {
				mod[i].call(mod, obj[i]);
			}
		}
	},
	then: function(){}
});