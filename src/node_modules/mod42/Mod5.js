var Base = require("base42");
var Mod1 = require("./Mod1");
var Mod2 = require("./Mod2");
var Mod4 = require("./Mod4");
var is = require("is");

// Add AutoMod to Mod4, and use a Settings object to create 

// mod could be a setMfn.fn...
// In that case, it has .set, but not .mfn 
var propWithSet = function(mod, obj, i){
	var modProp = mod[i];
	if (modProp.set.mfn && modProp.set.mfn.contextual){
		modProp.set.mfn.contextual(mod, i, obj[i]);
	} else {
		// // this doesn't work with Object.create, since the constructor isn't unique...
		// 	// nobody will have own constructor... 
		// 	// not sure what gives here..
		// if (this.hasOwnProperty(constructor))
		// 	this.constructor.base.prototype.propWithSet.call(this, mod, obj, i);
		// else
			Mod2.set.mfn.propWithSet.call(this, mod, obj, i);
	}
};

/*

!!!!! ONLY POJO-->SETTINGS ALLOWED @ skip properties!

For example, init can only be .set with a POJO, to trigger the mapping
If you try to set init with a fn or value, it'll use the regular set 

*/

var Settings = Mod2.extend({
	log: false,
	name: "Settings",
	instantiate: function(){
		this.setup();
		this.set.apply(this, arguments);
		this.initialize.apply(this, arguments);
	},
	setup: function(){
		// collect all default properties that don't start with _$_
		this.skip = ['parent'];
		for (var i in this){
			this.skip.push(i);
		}
	},
	newSettings: function(name, pojo){
		if (this.skip.indexOf(name) > -1){
			name = "_$_"+name;
		}

		this.log.group("newSettings", name);

		if (is.undef(this[name])){
			this[name] = new Settings({
				parent: this,
				name: name
			}, pojo);
			if (this.parent){
				this.log("this.parent", this.parent);
				if (this.parent.name === "methods" || this.parent.name === "props"){
					this.log("this.parent.name", this.parent.name);
					this.log("this.parent.parent.update("+name+")");
					this.parent.parent.update(name);
				}
			}
		} else {
			// if (this[name].set.mfn.contextual)
			this[name].set.mfn.contextual(this, name, pojo);
		}

		this.log.end();
	},
	data: function(own){
		var data = {}, subData, dataPropName;

		// init will be fn
		// init data, if added, will get mapped to _$_init
		// data.init should be data, not fn...
		// when iterating data, we need to remove _$_ from the name...
		
		// if its a skipped property, then don't add to data, period...

		for (var i in this){
			if (own && !this.hasOwnProperty(i))
				continue;
			// if its an original property, skip it, it's not data
			if (this.skip.indexOf(i) > -1)
				continue;


			if (this[i] && is.fn(this[i].data))
				subData = this[i].data(own);
			else
				subData = this[i];

			// if its an original property name, mapped to a _$_property name, we want to add that data, stripping the _$_.
			if (i.indexOf("_$_") === 0)
				dataPropName = i.replace("_$_", "");
			else
				dataPropName = i;

			data[dataPropName] = subData;
		}

		// data.name = this.name.replace("_$_", "");

		return data;
	},
	set: {
		// this is a "safe set", and could be used more generally
		contextual: function(parent, name, obj){
			// assume value is an object?
			if (parent.hasOwnProperty(name)){
				parent[name].set(obj);
			} else {
				// maybe run this through parent.set({name: .. }), so it can be wrapped, if its a Mod4
				parent[name] = Object.create(parent[name]).set(obj, {
					parent: parent
				});
			}
		},
		prop: function(mod, obj, i){
			var modProp = mod[i];
			if (is.pojo(obj[i])){
				if (is.undef(modProp) || mod.skip.indexOf(i) > -1)
					mod.newSettings(i, obj[i]);
			} else {
				Mod2.prototype.set.mfn.prop.call(this, mod, obj, i);
			}
		},
		propWithSet: propWithSet
	}
});


var Mod5 = Mod4.extend({
	name: "Mod5",
	set: {
		propWithSet: propWithSet
	}
});

Mod5.Settings = Settings;

module.exports = Mod5;