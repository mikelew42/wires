var Mfn2 = require("mod42/Mfn2");
var is = require("is");
var Method = require("log42/Method");
var logger = require("log42/logger");

var log = logger();

log.groupc("SetMfn2.js");

var install_logger = function(mod, value){
	var log = logger(value);
	Object.defineProperty(mod, "log", {
		configurable: true,
		get: function(){
			return log;
		},
		set: function(value){
			install_logger(this, value);
		}
	});
};

// if !hasOwn, don't set, default to .clone, if it has it
// if not, we need to clone manually

var SetMfn2 = module.exports = Mfn2.extend({
	name: "SetMfn2",
	log: false,
	main: function(mod){
		var args = [].slice.call(arguments, 1); // chop off the first arg
		for (var i = 0; i < args.length; i++){
			this.arg(mod, args[i]); // keep mod as first arg
		}
		this.then(mod);
		return mod; // important - see .prop method, where .set() return value is reassigned to parent...
	},
	arg: function(mod, arg){
		if (is.obj(arg))
			this.obj(mod, arg);
		else
			this.other(mod, arg);
	},
	other: function(mod, arg){
		console.warn("not sure how to set this", arg);
	},
	obj: function(mod, obj){
		for (var i in obj){
			this.prop(mod, i, obj[i]);
		}
		return mod;
	},
	props: {
		log: function(mod, prop, value){
			install_logger(mod, value);
		}
	},
	// todo: copy if !hasOwn, and then deep extend objects
	// todo: copy arrays if !hasOwn, and do push operations?
	prop: function(mod, prop, value){
		this.log.group(prop, value);
		var currentValue = mod[prop];
		if (this.props[prop]){
			this.props[prop].call(this, mod, prop, value);
		} else if (is.undef(currentValue)){
			this.stdProp(mod, prop, value);
		} else if (is.Class(currentValue)) {
			this.ClassProp(mod, prop, value);
		} else if (currentValue.set) { // dependent on is.def(mod[prop])
			this.propWithSet(mod, prop, value);
		} else if (is.fn(currentValue)) {
			this.fnProp(mod, prop, value);
		} else if (is.obj(currentValue)){
			this.objProp(mod, prop, value);
		} else {
			this.stdProp(mod, prop, value);
		}
		this.log.end();
	},
	// "prop with .set"
	propWithSet: function(mod, prop, value){
		if (!mod.hasOwnProperty(prop) && !mod[prop].mfn){
			this.stdProp(mod, prop, Object.create(mod[prop]).set(value));
			// set parent reference?
			// instantiate/initialize/setup(parent)?
		} else {
			// send this through stdProp?
			this.stdProp(mod, prop, mod[prop].set(value));
		}
	},
	ClassProp: function(mod, prop, value){
		if (is.Class(value)){
			this.stdProp(mod, prop, value);
		} else if (mod.hasOwnProperty(prop)) {
			mod[prop].prototype.set(value);
		} else {
			// send this through stdProp?
			mod[prop] = mod[prop].extend(value); // protect mod's prototype
		}
	},
	stdProp: function(mod, prop, value){
		if (mod[prop] !== value)
			mod[prop] = value;
	},
	fnProp: function(mod, prop, value){
		if (is.fn(value)){
			this.stdProp(mod, prop, value);
		} else {
			if (is.arr(value)){
				mod[prop].apply(mod, value);
			} else {
				mod[prop].call(mod, value);
			}
		}
	},
	objProp: function(mod, prop, value){
		if (is.obj(value)){
			if (mod.hasOwnProperty(prop)){
				this.obj(mod[prop], value)
			} else {
				this.stdProp(mod, prop, this.obj(Object.create(mod[prop]), value));
			}
			
		} else {
			console.warn("whoops");
		}
	},
	then: function(){}
});

var set = SetMfn2.make();

SetMfn2.set = set;
SetMfn2.prototype.set = set;

log.end();