Class.prototype.props
vs
instance.props

The .props are different from the definedProperties, but very coupled.  When you access a definedProperty, it access the value from this.props.getter

When we want to upgrade a prototype property, we could call prototype.prop...

We could also automatically upgrade them.

We could have:

Mod.extend({
	prop: {
		name: "value",
		name: {
			value: "value",
			methods, props, etc
		},
		name: Property({}) // (same as above)
	}
});

When to comes to caching, if we call prototype.prop("whatever"), and check this.props.whatever... it might exist on the prototype chain.

If we call .prop("whatever"), should it make a new one on this?  Yes, I think so...

Do we need to copy props?

So far, I think we're sharing .props...

Ugh, I think this is a major oversight... How should .props work with inheritance?

Can .props inherit with Object.create?


setter -> new Property if !hasOwn
This is good, but it doesn't solve the problem of the .props object.

* If we want inheritance, we can't use "this.props[name].getter" as the value, without some sophisticated copying...
	* We would need to protect the prototype chain, and make sure all props are copied to this.props
	* If there are events on the Property, for example, that's going to require some serious thought/planning
	* Maybe not - maybe we just copy them?

* To start, we could just ditch the whole "props" object.  Just use .prop to create them.  And maybe no need for that even - just do it automatically...