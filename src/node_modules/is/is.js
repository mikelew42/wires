var is = {
	arr: function(value){
		return toString.call(value) === '[object Array]';
	},
	obj: function(value){
		return typeof value === "object" && !is.arr(value);
	},
	val: function(value){
		return ['boolean', 'number', 'string'].indexOf(typeof value) > -1;
	},
	str: function(value){
		return typeof value === "string";
	},
	num: function(value){
		return typeof value === "number";
	},
	bool: function(value){
		return typeof value === 'boolean';
	},
	fn: function(value){
		return typeof value === 'function';
	},
	sfn: function(value){
		return is.fn(value) && value.main;
	},
	def: function(value){
		return typeof value !== 'undefined';
	},
	undef: function(value){
		return typeof value === 'undefined';
	},
	simple: function(value){ // aka non-referential
		return typeof value !== 'object' && !is.fn(value); // null, NaN, or other non-referential values?
	},
	Class: function(value){
		return is.fn(value) && value.extend;
	},
	// better than "Class"
	Mod: function(value){
		return is.fn(value) && value.extend;
	},
	/// seems to work
	pojo: function(value){
		return is.obj(value) && value.constructor === Object; // ?? is this supported cross-platform?
		
		return is.obj(value) && value.constructor.prototype === Object.prototype; // this won't work, value.constructor.prototype's prototype should be Object.prototype, but not directly equal
		return is.obj(value) && value.constructor.prototype instanceof Object;
		// ALL objects should have this, even modules, i think
		// or, return is.obj(value) && !is.mod(value);
		// --> allows for 
	},
	mod: function(value){
		return is.obj(value) && is.Mod(value.constructor);
	}
};
module.exports = is;