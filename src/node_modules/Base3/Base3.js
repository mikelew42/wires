// var Base2 = require("../Base/Base2");
var create = require("./create");
var Set = require("./Set");
var Extend = require("../ExtendModFn/ExtendModFn2");
var events = require("events");
var track = require("../track/track");
var createConstructor = require("./createConstructor");
var isExtensionOf = require("../Base/isExtensionOf");
var inst = require("./inst");
var setup = require("./setup");

var Base3 = createConstructor("Base3");
track(Base3);
track(Base3.prototype);


// when might this auto instantiation of Sub classes be undesireable?
// can we always easily turn it off?  not if its a reference...

Base3.assign({
	Extend: Extend,
	extend: new Extend({ name: "extend" }).fn, // this could be autoInstantiated?
	isExtensionOf: isExtensionOf,
	setup: setup,
	pset: new Set({
		name: "pset",
		main: function(Cls){
			var args = this.args(arguments); // chop off the first arg
			Cls.prototype.set.apply(Cls.prototype, args);
			return Cls; // for chaining
		}
	}).fn,
	set: new Set({ name: "set" }).fn,
	auto_sub: false,
	create_sub: function(parent, name){ // this is like the old "setup"
		name = name[0].toLowerCase() + name.substring(1);
		var mod = parent[name] = new this({
			name: name,
			parent: parent
		});

		// should this be before or after mod.init?
		// we could put something like this inside mod.create, and run it before init... if necessary
			// if we intend on sometimes calling .setup after init, then it should be able to run after init (even when called directly after "new")
			// if you MUST have it run before init, then you could just check if (this.parent) inside init, and run it manually (and then set this.setup = false, for example)
		if (mod.setup)
			mod.setup(parent);
	}
}, events.prototype); // .on, .emit, etc. .extend will clobber the ._events

Base3.prototype.assign({
	create: create,
	inst: inst,
	set: new Set({ name: "set" }).fn, // not a true Sub module (not autoInstantiated per instance)
	init: function(){}
});

module.exports = Base3;

/*
Do we want to use .set on extend?
- Recursively set?
- Set as a ModFn allows great extensibility...
- Matches the new ({})--> .set pattern

Should be as close to assign as possible... and maybe split from a more advanced .set, in case it deviates:
- override fns with fns

Currently, set doesn't do much other than assign:
- it calls .set on props, if present
- it calls fns with arrays or non-fn values
- it allows easy override, if you need to upgrade
- it provides override points for set("str", 123, etc)

*/